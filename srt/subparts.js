// Generated by LiveScript 1.3.1
(function(){
  var terminals, getChildren, getParseConstituents, jsonfile, longestkey, all_cards, lines_chinese, ref_translations, parse_trees, makecards, i$, len$, idx, line, tree, constituents, sentence, cards;
  terminals = function(s, lang){
    var output, current_terminal, i$, len$, c, last_paren_type, to_print, ref$, tag, terminal;
    output = [];
    current_terminal = [];
    for (i$ = 0, len$ = s.length; i$ < len$; ++i$) {
      c = s[i$];
      if (c === '(') {
        last_paren_type = '(';
        current_terminal = [];
      } else if (c === ')') {
        if (last_paren_type === '(') {
          if (current_terminal.length > 0) {
            to_print = current_terminal.join('');
            ref$ = to_print.split(' '), tag = ref$[0], terminal = ref$[1];
            output.push(terminal);
          }
        }
        last_paren_type = ')';
        current_terminal = [];
      } else {
        current_terminal.push(c);
      }
    }
    if (lang === 'zh') {
      return output.join('');
    }
    return output.join(' ');
  };
  getChildren = function(s){
    var curchild, children, depth, i$, len$, c;
    curchild = [];
    children = [];
    depth = 0;
    for (i$ = 0, len$ = s.length; i$ < len$; ++i$) {
      c = s[i$];
      if (c === '(') {
        depth += 1;
      }
      if (depth >= 2) {
        curchild.push(c);
      }
      if (c === ')') {
        depth -= 1;
        if (depth === 1) {
          children.push(curchild.join(''));
          curchild = [];
        }
      }
    }
    return children;
  };
  getParseConstituents = function(parse, lang){
    var output, agenda, current, i$, ref$, len$, child, curt, childt;
    output = {};
    agenda = [parse];
    while (agenda.length > 0) {
      current = agenda.pop(0);
      for (i$ = 0, len$ = (ref$ = getChildren(current)).length; i$ < len$; ++i$) {
        child = ref$[i$];
        agenda.push(child);
        curt = terminals(current, lang);
        childt = terminals(child, lang);
        if (curt !== childt) {
          if (output[curt] == null) {
            output[curt] = [];
          }
          output[curt].push(childt);
        }
      }
    }
    return output;
  };
  jsonfile = require('jsonfile');
  longestkey = function(constituents){
    var longest_key, i$, ref$, len$, x;
    longest_key = '';
    for (i$ = 0, len$ = (ref$ = Object.keys(constituents)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x.length > longest_key.length) {
        longest_key = x;
      }
    }
    return longest_key;
  };
  all_cards = [];
  lines_chinese = jsonfile.readFileSync('lines_chinese.json');
  ref_translations = jsonfile.readFileSync('ref_translations.json');
  parse_trees = jsonfile.readFileSync('parse_trees.json');
  makecards = function(sentence, constituents, parent){
    var output, card, children, i$, len$, child, child_cards;
    output = [];
    card = {};
    card.sentence = sentence;
    if (parent != null) {
      card.parent = parent;
    }
    children = constituents[sentence];
    if (children != null) {
      card.children = children;
    }
    output.push(card);
    if (children != null) {
      for (i$ = 0, len$ = children.length; i$ < len$; ++i$) {
        child = children[i$];
        child_cards = makecards(child, constituents, sentence);
        output = output.concat(child_cards);
      }
    }
    return output;
  };
  for (i$ = 0, len$ = lines_chinese.length; i$ < len$; ++i$) {
    idx = i$;
    line = lines_chinese[i$];
    tree = parse_trees[line];
    constituents = getParseConstituents(tree, 'zh');
    sentence = longestkey(constituents);
    cards = makecards(sentence, constituents, null);
    cards[0].idx = idx;
    cards[0].sentence_orig = line;
    cards[0].engsub = ref_translations[line];
    all_cards = all_cards.concat(cards);
  }
  jsonfile.writeFileSync('cards_notrans.json', all_cards);
}).call(this);
